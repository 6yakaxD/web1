apache - 47075
fcgi - 47085

scp -r -P 2222 .\httpd-root\ .\start_it.sh .\static\ s409659@se.ifmo.ru:./

ssh -p 2222 s409659@helios.cs.ifmo.ru -L 47075:localhost:47075



1. Псевдоклассовые селекторы

:hover- выбирает элемент, когда пользователь наводит на него курсор
:active- выбирает элемент при его активации (например, щелчке)
:focus- выбирает элемент, когда он находится в фокусе (например, когда пользователь нажимает на поле ввода формы)
:visited- выбирает ссылку, которая была посещена
:link- выбирает не посещенную ссылку
:first-child- выбирает первый дочерний элемент своего родителя
:last-child- выбирает последний дочерний элемент своего родителя
:nth-child(n)- выбирает n-ный дочерний элемент своего родителя
:enabled- выбирает элемент формы, который включен
:disabled- выбирает элемент формы, который отключен
:checked- выбирает флажок или переключатель, который отмечен

2. Селекторы элементов

h1- выбирает все <h1>элементы
p- выбирает все <p>элементы
div- выбирает все <div>элементы
a- выбирает все <a>элементы
img- выбирает все <img>элементы
input- выбирает все <input>элементы
table- выбирает все <table>элементы
tr- выбирает все <tr>элементы
td- выбирает все <td>элементы

3. Селекторы псевдоэлементов

::before- выбирает псевдоэлемент, который вставляется перед элементом
::after- выбирает псевдоэлемент, который вставляется после элемента
::first-line- выбирает первую строку элемента
::first-letter- выбирает первую букву элемента
::selection- выбирает часть элемента, выбранную пользователем

4. Селекторы классов

.header- выбирает все элементы с классомheader
.footer- выбирает все элементы с классомfooter
.nav- выбирает все элементы с классомnav
.container- выбирает все элементы с классомcontainer

5. Свойства CSS — наследование и каскадирование

Наследование : Некоторые свойства CSS наследуются от родительских элементов, таких как font-family, color, и text-align. Например:
body {
  font-family: Arial, sans-serif;
}
p {
  /* inherits font-family from body */
}

Каскадирование: стили CSS могут быть каскадированы из нескольких таблиц стилей или из нескольких правил в одной таблице стилей. Стили применяются в следующем порядке:
Стили браузера по умолчанию
Внешние таблицы стилей (связанные или импортированные)
Внутренние стили (в <style>блоке)
Встроенные стили (в style атрибуте)
Например:
/* external stylesheet */
body {
  background-color: #f2f2f2;
}

/* internal stylesheet */
<style>
  body {
    background-color: #fff;
  }
</style>

<!-- inline style -->
<body style="background-color: #ccc;">
  <!-- content -->
</body>
В этом примере встроенный стиль переопределит внутренние и внешние стили, а цвет фона элемента <body>будет #ccc.





Что такое API Fetch?
    JavaScript API для выполнения сетевых запросов
    API на основе обещаний, что означает, что он возвращает обещание, которое разрешается в объект ответа
    В JavaScript Promise — представляет значение, которое может быть пока недоступно, но будет разрешено в какой-то момент в будущем.
    Promise может находиться в одном из трех состояний: Ожидание, Выполнено, Отклонено
    Обещания используются для обработки асинхронных операций
Fetch API — это современная реализация концепции AJAX

Какие существуют альтернативы Fetch API?
XMLHttpRequest (XHR) : традиционный способ выполнения запросов AJAX, который по-прежнему поддерживается большинством браузеров.
jQuery.ajax() : популярная библиотека JavaScript jQuery предоставляет удобный способ создания AJAX-запросов с помощью своего ajax() метода.
Axios : популярная библиотека JavaScript для выполнения HTTP-запросов, которая обеспечивает более удобный и гибкий способ выполнения запросов по сравнению с Fetch API.






Где хранить данные на клиенте
Куки (Cookies): это небольшие текстовые файлы, которые хранятся на клиенте и отправляются на сервер при каждом запросе.
Сессии (Sessions): это механизм хранения данных на сервере, который связан с конкретным пользователем. Когда пользователь авторизуется, сервер создает сессию и хранит данные о пользователе в этой сессии. Сессии обычно хранятся на сервере, но могут быть также хранены на клиенте в виде куки.
SessionStorage: SessionStorage - это механизм хранения данных на клиенте, который позволяет хранить данные только в течение одной сессии. Когда пользователь закрывает браузер, данные в sessionStorage удаляются.
LocalStorage: LocalStorage - это механизм хранения данных на клиенте, который позволяет хранить данные на постоянной основе. Данные в localStorage не удаляются, даже если пользователь закрывает браузер.
IndexedDB: IndexedDB - это механизм хранения данных на клиенте, который позволяет хранить большие объемы данных в виде базы данных. IndexedDB поддерживает транзакции и индексирование данных.
Web Storage: Web Storage - это механизм хранения данных на клиенте, который позволяет хранить данные в виде ключ-значение. Web Storage поддерживает два типа хранения: sessionStorage и localStorage.
Cache API: Cache API - это механизм хранения данных на клиенте, который позволяет хранить данные в виде кэша. Cache API позволяет хранить данные на постоянной основе и поддерживает управление кэшем.
Service Worker: Service Worker - это механизм хранения данных на клиенте, который позволяет хранить данные в виде кэша. Service Worker позволяет хранить данные на постоянной основе и поддерживает управление кэшем.







=============
Метод event.preventDefault() используется для предотвращения выполнения действия по умолчанию для события.
В контексте onclick обработчика событий event.preventDefault() используется для предотвращения действия по умолчанию события щелчка, которое заключается в отправке формы или переходе по ссылке.
При отправке формы или нажатии на ссылку браузер выполняет действие по умолчанию, например, отправляет данные формы на сервер или переходит на новую страницу.
Вызывая event.preventDefault(), вы можете предотвратить выполнение этого действия по умолчанию, что позволяет вам обрабатывать событие программно.
В этом конкретном случае event.preventDefault() используется в сочетании с sendData() для предотвращения отправки формы обычным способом.
Вместо этого sendData() вызывается функция, которая, скорее всего, отправляет данные формы на сервер с помощью запроса AJAX или какого-либо другого механизма.
Отключив отправку форм по умолчанию, вы сможете получить больший контроль над процессом отправки форм, например:
Проверка данных формы перед отправкой на сервер
Отправка данных формы с помощью запроса AJAX вместо полной перезагрузки страницы
Выполнение дополнительной обработки или расчетов перед отправкой данных формы
Предотвращение многократной отправки формы
В целом, event.preventDefault() это полезный метод для переопределения поведения события по умолчанию и предоставления вместо него пользовательской реализации.
=================
onclick: Это атрибут события, который определяет сценарий, который будет выполнен при щелчке по элементу.
event.preventDefault(): Это метод, который предотвращает выполнение действия по умолчанию для события. В этом случае он предотвращает поведение элемента по умолчанию при щелчке.
Когда вы нажимаете на элемент, например кнопку или ссылку, браузер выполняет действие по умолчанию. Например, когда вы нажимаете на ссылку, браузер переходит на связанный URL. Когда вы нажимаете на кнопку, браузер отправляет форму.
Вызывая event.preventDefault(), вы можете предотвратить возникновение этого поведения по умолчанию. Это полезно, когда вы хотите обрабатывать событие щелчка программно, а не позволять браузеру выполнять его действие по умолчанию.
В контексте отправки формы event.preventDefault()может использоваться для предотвращения отправки формы при нажатии кнопки отправки. Это позволяет вам выполнять проверку или другую обработку данных формы перед ее отправкой.













ВОПРОСЫ
-----------------------------------------
-Протокол HTTP. Структура запросов и ответов, методы запросов, коды ответов сервера, заголовки запросов и ответов.
    Структура запросов
        Стартовая строка (start line) — используется для описания версии используемого протокола и другой информации — вроде запрашиваемого ресурса или кода ответа. Как можно понять из названия, ее содержимое занимает ровно одну строчку.
        HTTP-заголовки (HTTP Headers) — несколько строчек текста в определенном формате, которые либо уточняют запрос, либо описывают содержимое тела сообщения.
        Пустая строка, которая сообщает, что все метаданные для конкретного запроса или ответа были отправлены.
        Опциональное тело сообщения, которое содержит данные, связанные с запросом, либо документ (например HTML-страницу), передаваемый в  ответе.
    ПРИМЕР:
    POST /users HTTP/1.1
    Host: example.com
    Content-Type: application/json
    Content-Length: 57
    {
      "name": "John Doe",
      "age": 30
    }

    Структура ответов
        Стартовая строка (start line): она содержит версию протокола, код состояния и текстовое описание кода состояния.
        Заголовки (headers): они содержат дополнительную информацию об ответе, такую как тип данных, кодировку и т. д.
        Тело ответа (response body): оно содержит данные, которые отправляются клиенту.
    ПРИМЕР:
    HTTP/1.1 201 Created
    Content-Type: application/json
    Content-Length: 34
    {
      "id": 123,
      "name": "John Doe",
      "age": 30
    }

    Методы запросов
        GET: запросить ресурс с сервера.
        POST: отправить данные на сервер для обработки.
        PUT: обновить ресурс на сервере.
        DELETE: удалить ресурс с сервера.

    Заголовки HTTP-запросов:
    Accept : указывает формат тела ответа, который может обработать клиент (например application/json, text/html, и т. д.)
    Accept-Language : указывает язык текста ответа, который предпочитает клиент (например en-US, fr-FR, и т. д.)
    Авторизация : предоставляет учетные данные аутентификации или токены для доступа к защищенным ресурсам.
    Content-Type : указывает формат тела запроса (например application/json, multipart/form-dataи т. д.)
    Content-Length : указывает размер тела запроса в байтах.
    Хост : указывает доменное имя сервера.
    User-Agent : предоставляет информацию о клиентском программном обеспечении и операционной системе, сделавшей запрос.
    Cookie : отправляет файлы cookie на сервер для аутентификации или управления сеансом.
    Referer : указывает URL-адрес страницы, с которой был сделан запрос.

    Заголовки HTTP-ответа:
    Content-Type : определяет формат тела ответа (например application/json, text/html и т.д.)
    Content-Length : указывает размер тела ответа в байтах.
    Set-Cookie : устанавливает файлы cookie на клиенте для аутентификации или управления сеансом.
    Cache-Control : задает инструкции по кэшированию для ответа.
    Истекает : указывает дату и время, после которого ответ следует считать устаревшим.
    ETag : предоставляет уникальный идентификатор для ответа, что упрощает кэширование и управление версиями.
    Местоположение : указывает URL-адрес перенаправления или местоположение вновь созданного ресурса.
    Сервер : предоставляет информацию о программном обеспечении сервера и операционной системе.

    Успешные ответы (200-299)
    200 OK: Запрос выполнен успешно.
    201 Создано: Запрос был выполнен и привел к созданию нового ресурса.
    202 Принят: Запрос принят к обработке, но обработка не завершена.
    203 Недостоверная информация: Сервер успешно обработал запрос, но возвращает информацию, которая может быть из другого источника.
    204 Нет контента: Сервер успешно обработал запрос, но не возвращает никакого контента.
    Перенаправления (300-399)
    301 Перемещено навсегда: целевому ресурсу был назначен новый постоянный URI, и любые будущие ссылки на этот ресурс должны использовать один из включенных URI.
    302 Найдено: целевой ресурс временно находится под другим URI.
    303 См. Другое: Сервер перенаправляет агента пользователя на другой ресурс, на что указывает URI в поле заголовка Location, который может отличаться от URI Request-URI, а может и нет.
    307 Временное перенаправление: целевой ресурс временно находится под другим URI.
    Ошибки клиента (400-499)
    400 Bad Request: запрос не может быть понят сервером из-за неверного синтаксиса.
    401 Неавторизованный: запрос не был применен, поскольку отсутствуют действительные учетные данные аутентификации для целевого ресурса.
    403 Запрещено: Сервер понял запрос, но отказывается его авторизовать.
    404 Not Found: Исходный сервер не нашел текущего представления для целевого ресурса или не желает раскрывать информацию о его существовании.
    405 Метод не разрешен: Метод, полученный в строке запроса, известен исходному серверу, но не поддерживается целевым ресурсом.
    Ошибки сервера (500-599)
    500 Внутренняя ошибка сервера: сервер столкнулся с непредвиденным условием, которое не позволило выполнить запрос.
    501 Не реализовано: сервер не поддерживает функциональность, необходимую для выполнения запроса.
    502 Bad Gateway: Сервер, выступая в качестве шлюза или прокси-сервера, получил недопустимый ответ от вышестоящего сервера, к которому он обращался при попытке выполнить запрос.
    503 Служба недоступна: В настоящее время сервер не может обработать запрос из-за временной перегрузки или планового технического обслуживания, которое, вероятно, будет устранено через некоторое время.
    504 Gateway Timeout: Сервер, выступая в качестве шлюза или прокси-сервера, не получил своевременного ответа от вышестоящего сервера, к которому ему необходимо было получить доступ для выполнения запроса.

-Язык разметки HTML. Особенности, основные теги и атрибуты тегов.

-Структура HTML-страницы. Объектная модель документа (DOM).
    Document Object Model
    !DOCKTYPE
    <html> <head> </head> <body> </body> </html>

-HTML-формы. Задание метода HTTP-запроса. Правила размещения форм на страницах, виды полей ввода.

	При создании HTML-формы необходимо указать метод HTTP-запроса, который будет отправлен на сервер при отправке формы. Два наиболее распространенных метода:

	GET : Этот метод отправляет данные формы в URL как строку запроса. Обычно используется для извлечения данных с сервера.
	POST : Этот метод отправляет данные формы в теле запроса. Обычно используется для отправки данных на сервер для обработки или хранения.
	
	Правила размещения форм на страницах
	Вот несколько правил, которые следует учитывать при размещении форм на веб-страницах:

	Форму можно разместить в любом месте элемента <body>HTML-документа.
	Форму нельзя поместить внутрь другой формы.
	Форма может содержать несколько элементов формы, таких как поля ввода, флажки и кнопки.
	Типы полей ввода
	HTML-формы поддерживают различные типы полей ввода, в том числе:

	Ввод текста : однострочное поле ввода текста, созданное с помощью <input type="text">элемента.
	Ввод пароля : однострочное поле ввода пароля, созданное с помощью <input type="password">элемента.
	Флажок : поле ввода флажка, созданное с использованием <input type="checkbox">элемента.
	Радиокнопка : поле ввода радиокнопки, созданное с использованием <input type="radio">элемента.
	Раскрывающийся список : поле ввода раскрывающегося списка, созданное с использованием <select>элемента.
	Textarea : многострочное поле ввода текста, созданное с помощью <textarea>элемента.
	Ввод файла : поле ввода файла, созданное с использованием <input type="file">элемента.
	Скрытый ввод : Скрытое поле ввода, созданное с использованием <input type="hidden">элемента.

-Каскадные таблицы стилей (CSS). Структура - правила, селекторы. Виды селекторов, особенности их применения. Приоритеты правил. Преимущества CSS перед непосредственным заданием стилей через атрибуты тегов.

-LESS, Sass, SCSS. Ключевые особенности, сравнительные характеристики. Совместимость с браузерами, трансляция в "обычный" CSS.

	LESS, Sass и SCSS — популярные препроцессоры, используемые для расширения функциональности CSS
	
	Все три являются препроцессорами, которые позволяют писать CSS с использованием конструкций языка программирования, таких как переменные, функции и управляющие структуры.
	Все они компилируются в обычный CSS, что делает их совместимыми с любым браузером или устройством, поддерживающим CSS.
	Все они направлены на то, чтобы сделать CSS более эффективным, модульным и простым в обслуживании.
	
	LESS
	LESS (Leaner Style Sheets) — это препроцессор на основе JavaScript.
	Он известен своей простотой и удобством использования, что делает его отличным выбором для небольших проектов или для тех, кто только начинает знакомиться с препроцессорами.
	У LESS меньшее сообщество по сравнению с Sass и SCSS, но он по-прежнему широко используется.
	LESS часто используется совместно с фреймворками JavaScript, такими как Bootstrap.
	
	Sass
	Sass (Syntactically Awesome StyleSheets) — это препроцессор на основе Ruby.
	Он известен своими мощными функциями, гибкостью и большим сообществом пользователей и участников.
	Sass имеет два синтаксиса: Sass (синтаксис с отступами) и SCSS (синтаксис, подобный CSS).
	Sass широко используется в крупномасштабных проектах и ​​часто пользуется популярностью у разработчиков, которые ценят его мощный набор функций.
	
	SCSS
	SCSS (Sassy CSS) — это синтаксис Sass, подобный CSS.
	По сути, это надмножество CSS, позволяющее разработчикам CSS легко перейти на SCSS.
	SCSS — самый популярный синтаксис для Sass, который часто используется взаимозаменяемо с термином «Sass».
	SCSS широко используется в современной веб-разработке, особенно с такими фреймворками, как Bootstrap и Bulma.
	
	Обзор LESS, Sass и SCSS

    LESS, Sass и SCSS — три популярных препроцессора, используемых для расширения функциональности CSS. Они позволяют разработчикам писать более эффективный, модульный и повторно используемый код, который затем транслируется в обычный CSS, понятный веб-браузерам.

    Основные характеристики

    Вот основные особенности каждого препроцессора:

    МЕНЬШЕ
    Переменные : позволяет определять переменные для хранения значений, которые можно повторно использовать в коде.
    Миксины : позволяют создавать повторно используемые блоки кода, которые можно смешивать с другими селекторами.
    Функции : Поддерживает математические функции и операции.
    Вложенные правила : позволяет использовать вложенные правила для создания более организованного и эффективного кода.
    Сасс
    Переменные : аналогично LESS, позволяет определять переменные для хранения значений.
    Вложенность : поддерживает вложенные селекторы для создания более организованного кода.
    Миксины : Подобно LESS, позволяют создавать повторно используемые блоки кода.
    Директивы управления : поддерживают условные операторы (например, if, else) и циклы (например, for, while).
    Функции : Поддерживает математические функции и операции.
    ССС
    Надмножество CSS : SCSS — это надмножество CSS, то есть любой допустимый CSS также является допустимым SCSS.
    Переменные : подобно LESS и Sass, позволяет определять переменные для хранения значений.
    Вложенность : поддерживает вложенные селекторы для создания более организованного кода.
    Миксины : подобно LESS и Sass, позволяют создавать повторно используемые блоки кода.
    Директивы управления : поддерживают условные операторы (например, if, else) и циклы (например, for, while).
    Функции : Поддерживает математические функции и операции.
    Сравнительные характеристики

    Вот краткое сравнение трех препроцессоров:

    Синтаксис : LESS использует более краткий синтаксис, в то время как Sass и SCSS используют более подробный синтаксис, похожий на CSS.
    Популярность : Sass — самый популярный препроцессор, за ним следуют LESS и SCSS.
    Поддержка браузеров : Ни один из препроцессоров не поддерживается браузерами из коробки. Их необходимо транслировать в обычный CSS с помощью компилятора или транспилятора.
    Совместимость с браузерами и перевод

    Чтобы использовать любой из этих препроцессоров, вам нужно перевести их в обычный CSS, который будет понятен веб-браузерам. Это можно сделать с помощью:

    Инструменты командной строки : такие как компилятор LESS или компилятор Sass.
    Инструменты сборки : такие как Webpack или Gulp, которые могут интегрироваться с препроцессорами.
    Онлайн-инструменты : такие как CodePen или JSFiddle, которые обеспечивают встроенную поддержку препроцессоров.
    После перевода полученный CSS-код можно без проблем использовать в любом веб-браузере.

-Клиентские сценарии. Особенности, сферы применения. Язык JavaScript.

-Версии ECMAScript, новые возможности ES6 и ES7.

    ECMAScript — это стандарт для языка сценариев. Это набор правил, спецификация, описывающая синтаксис, семантику и поведение языка сценариев. Это не конкретная реализация, а скорее план, которому должны следовать реализации.
    Думайте об этом как о книге рецептов для языка сценариев. Книга рецептов (ECMAScript) описывает, как написать язык сценариев, какие функции он должен иметь и как он должен себя вести. Затем разные компании или организации могут использовать эту книгу рецептов для создания собственной реализации языка, например JavaScript, JScript или SpiderMonkey.
    ECMAScript не является физическим объектом, как язык программирования, на котором можно писать код. Это документ, в котором изложены правила и рекомендации по созданию языка сценариев.
    Вот аналогия, которая поможет проиллюстрировать эту концепцию:
    ECMAScript — это как проект дома.
    JavaScript — это как дом, построенный по этому чертежу.
    JScript — это как еще один дом, построенный по тому же чертежу, но с некоторыми отличиями в конструкции или материалах.
    Все эти дома (реализации) следуют одному и тому же проекту (стандарт ECMAScript), но они могут иметь некоторые различия в способе строительства или в предлагаемых функциях.
    Итак, подведем итог: ECMAScript — это стандарт, спецификация, проект языка сценариев. Это не сам язык программирования, а скорее набор правил, которым должны следовать языки программирования.

    Версии ECMAScript и новые возможности в ES6 и ES7

    Как я уже упоминал ранее, ECMAScript претерпел несколько изменений, каждое из которых представляло новые возможности и улучшения. Вот краткий обзор версий и некоторых примечательных функций, представленных в ES6 и ES7:

    Версии ECMAScript:

    ES1 (1997) : первое издание стандарта ECMAScript.
    ES3 (1999) : третье издание, в котором добавлена ​​поддержка регулярных выражений, обработка исключений и другие функции.
    ES5 (2009) : пятое издание, в котором был представлен строгий режим, поддержка JSON и другие улучшения.
    ES6 (2015) : шестое издание, также известное как ECMAScript 2015, внесшее значительные изменения в язык.
    ES7 (2016) : седьмое издание, также известное как ECMAScript 2016, в которое добавлены новые функции и улучшения.
    ES8 (2017) : восьмое издание, в котором были представлены такие функции, как async/await, Object.values()и Object.entries().
    ES9 (2018) : девятое издание, в котором добавлены такие функции, как асинхронная итерация, Promise.prototype.finally()и RegExpулучшения.
    ES10 (2019) : десятое издание, в котором представлены такие функции, как необязательная привязка catch, String.prototype.matchAll()и globalThis.
    ES11 (2020) : одиннадцатое издание, в которое добавлены такие функции, как Promise.allSettled()метод, String.prototype.replaceAll()и globalThis.
    Новые возможности в ES6:

    Классы : введен новый синтаксис для создания классов, аналогичный другим объектно-ориентированным языкам.
    Обещания : добавлена ​​поддержка обещаний, которые позволяют более эффективно обрабатывать асинхронные операции.
    Генераторы : введены генераторы, которые позволяют функциям выдавать значения и возобновлять их выполнение позже.
    Стрелочные функции : введен краткий синтаксис для создания функций, аналогичный лямбда-функциям в других языках.
    Параметры по умолчанию : функциям разрешено иметь значения параметров по умолчанию.
    Оставшиеся параметры : введен ...синтаксис для сбора оставшихся аргументов в функции.
    Деструктуризация : введен краткий синтаксис для извлечения значений из массивов и объектов.
    Модули : введен новый синтаксис для импорта и экспорта модулей.
    Новые возможности в ES7:
    Array.prototype.includes() : добавлен метод для проверки того, содержит ли массив определенное значение.
    Оператор возведения в степень : введен **оператор возведения в степень.
    Async/await : улучшенная поддержка асинхронного программирования с использованием синтаксиса async/await.
    Это всего лишь несколько примеров множества функций, представленных в ES6 и ES7. Если вы хотите узнать больше о конкретной функции или версии, не стесняйтесь спрашивать!

-Синхронная и асинхронная обработка HTTP-запросов. AJAX.

    Синхронная и асинхронная обработка HTTP-запросов: AJAX
    Когда дело доходит до обработки HTTP-запросов, есть два основных подхода: синхронная и асинхронная обработка. Давайте углубимся в каждый из этих методов и рассмотрим, как AJAX (асинхронный JavaScript и XML) вписывается в общую картину.
    Синхронная обработка
    При синхронной обработке клиент (обычно веб-браузер) отправляет HTTP-запрос на сервер и ждет ответа, прежде чем продолжить выполнение любого дальнейшего кода. Это означает, что клиент блокируется до тех пор, пока сервер не ответит, что может привести к замедлению пользовательского опыта.
    AJAX (асинхронный JavaScript и XML)
    AJAX — это метод, который обеспечивает асинхронную связь между клиентом и сервером с использованием JavaScript и XML (или других форматов данных, таких как JSON). AJAX позволяет веб-приложениям обновляться динамически, не требуя полной перезагрузки страницы.
    AJAX обычно включает в себя следующие шаги:
    Клиент отправляет асинхронный HTTP-запрос на сервер, используя объект XMLHttpRequest (или API Fetch в современных браузерах).
    Сервер обрабатывает запрос и возвращает ответ в формате XML или JSON.
    Клиент получает ответ и динамически обновляет веб-страницу с помощью JavaScript.
    AJAX обычно используется в веб-приложениях для обеспечения более отзывчивого и интерактивного взаимодействия с пользователем.

-Библиотека jQuery. Назначение, основные API. Использование для реализации AJAX и работы с DOM.

    Библиотека jQuery: назначение, основной API и использование для манипуляций AJAX и DOM

    jQuery — популярная библиотека JavaScript, которая упрощает процесс взаимодействия с документами HTML, облегчая обход и манипулирование объектной моделью документа (DOM). Она также предоставляет удобный способ обработки событий, анимации элементов и выполнения запросов AJAX.

    Цель jQuery

    Основное назначение jQuery:

    Упростите манипуляции и обход DOM
    Обеспечить единообразный API для разных браузеров
    Обеспечить легкую обработку событий и анимацию
    Упрощение запросов AJAX и извлечения данных JSONP (JSON с заполнением)
    Основной API

    Некоторые из основных компонентов API jQuery включают в себя:

    Селекторы : используются для выбора и управления элементами DOM, например, $('#myId')или$('.myClass')
    Методы : выполнение действий над выбранными элементами, например, $('#myId').hide()или$('.myClass').css('color', 'red')
    События : обработка событий, таких как щелчки или эффекты наведения, например,$('#myButton').on('click', function(){ ... })
    AJAX : выполнение асинхронных запросов, например,$.ajax({ url: 'https://example.com/data', method: 'GET' })
    Утилиты : предоставляют вспомогательные функции, такие как $.trim()или$.each()
    Использование jQuery для AJAX

    jQuery предоставляет удобный способ выполнения AJAX-запросов с использованием $.ajax()метода.
    $.ajax({
      url: 'https://example.com/data',
      method: 'GET',
      dataType: 'json',
      success: function(data) {
        console.log(data);
      },
      error: function(xhr, status, error) {
        console.error(error);
      }
    });

    Этот код отправляет запрос GET в https://example.com/data, ожидая ответа JSON. При получении ответа successсрабатывает функция обратного вызова, а errorфункция обратного вызова срабатывает, если возникает ошибка.

    Использование jQuery для манипуляции DOM

    jQuery предоставляет широкий спектр методов для манипулирования DOM, например:

    Добавление элементов :$('#myContainer').append('<p>New paragraph</p>')
    Удаление элементов :$('#myElement').remove()
    Изменение атрибутов :$('#myLink').attr('href', 'https://example.com/new-link')
    Обход DOM :$('#myParent').find('.child-elements')
    Вот пример использования jQuery для динамического обновления веб-страницы:
    $('#myButton').on('click', function() {
      $('#myContainer').html('<p>New content</p>');
      $('#myLink').attr('href', 'https://example.com/new-link');
    });

    Этот код обновляет содержимое #myContainerи изменяет hrefатрибут #myLinkпри #myButtonщелчке по .


-Реализация AJAX с помощью SuperAgent.

    Реализация AJAX с помощью SuperAgent

    SuperAgent — это легкая, гибкая и мощная библиотека JavaScript для выполнения запросов AJAX. Она предоставляет простой и интуитивно понятный API для отправки HTTP-запросов и взаимодействия с веб-серверами.

    Почему СуперАгент?

    SuperAgent — популярный выбор для выполнения AJAX-запросов благодаря своим:

    Легкость : SuperAgent занимает мало места, что делает его идеальным для современных веб-приложений.
    Гибкость : предоставляет широкий спектр возможностей для настройки запросов, таких как заголовки, строки запроса и тела запроса.
    API на основе обещаний : SuperAgent возвращает обещания, что упрощает обработку асинхронных запросов.
    Базовое использование

    Вот пример создания запроса GET с использованием SuperAgent:
    const request = require('superagent');

    request
      .get('https://example.com/data')
      .then(response => {
        console.log(response.body);
      })
      .catch(error => {
        console.error(error);
      });

    Этот код отправляет запрос GET https://example.com/dataи регистрирует тело ответа на консоли. Если происходит ошибка, он перехватывает ошибку и регистрирует ее на консоли.

    Настройка заголовков запроса

    Вы можете задать заголовки запроса, используя set()метод:
    request
      .get('https://example.com/data')
      .set('Accept', 'application/json')
      .set('Authorization', 'Bearer YOUR_TOKEN')
      .then(response => {
        console.log(response.body);
      });

    Этот код устанавливает Acceptзаголовок в значение application/json, а Authorizationзаголовок в значение Bearer YOUR_TOKEN.

    Отправка тела запроса

    Вы можете отправить тело запроса, используя send()метод:
    request
      .post('https://example.com/create')
      .send({ name: 'John Doe', age: 30 })
      .then(response => {
        console.log(response.body);
      });

    Этот код отправляет запрос POST https://example.com/createс телом запроса JSON, содержащим свойства nameи age.

    Строки запроса

    Вы можете добавлять строки запроса, используя query()метод:
    request
      .get('https://example.com/search')
      .query({ q: 'javascript', page: 2 })
      .then(response => {
        console.log(response.body);
      });




-Серверные сценарии. CGI - определение, назначение, ключевые особенности.

    Скрипты на стороне сервера: CGI — определение, цель и основные характеристики

    Определение: CGI (Common Gateway Interface) — стандартный протокол для веб-серверов, позволяющий им выполнять внешние программы или скрипты, что позволяет им взаимодействовать с веб-браузерами и генерировать динамический веб-контент. Скрипты CGI обычно пишутся на таких языках программирования, как C, Perl или Python, и выполняются на стороне сервера.

    Назначение: Основная цель CGI — дать возможность веб-серверам генерировать динамический веб-контент, взаимодействовать с базами данных и выполнять сложные задачи, которые не могут быть выполнены только статическими HTML-страницами. Скрипты CGI можно использовать для:

    Обработка вводимых пользователем данных из веб-форм
    Создание динамических веб-страниц на основе пользовательского ввода или данных из базы данных.
    Аутентификация пользователей и управление сеансами
    Выполнять сложные вычисления или обработку данных
    Взаимодействие с внешними системами или службами
    Основные характеристики:

    Независимость от платформы : CGI-скрипты могут быть написаны на разных языках программирования и работать на разных операционных системах.
    Без сохранения состояния : CGI-скрипты не поддерживают постоянное соединение с клиентом; каждый запрос обрабатывается как новая независимая транзакция.
    Модель «запрос-ответ» : CGI-скрипты получают входные данные от клиента (например, данные формы) и генерируют выходные данные (например, HTML-страницы) в ответ.
    Переменные среды : CGI-скрипты могут получать доступ к переменным среды, установленным веб-сервером, таким как QUERY_STRINGили REMOTE_ADDR.
    Стандартный ввод/вывод : CGI-скрипты получают входные данные из стандартного потока ввода и отправляют выходные данные в стандартный поток вывода.
    CGI широко использовался в прошлом, но у него есть некоторые ограничения, такие как проблемы с производительностью и безопасностью. Современная веб-разработка перешла к более эффективным и безопасным технологиям, таким как FastCGI, mod_perl и веб-фреймворкам, таким как Ruby on Rails или Django.

-FastCGI - особенности технологии, преимущества и недостатки относительно CGI.

    FastCGI: особенности, преимущества и недостатки по сравнению с CGI

    Функции:

    Постоянные соединения : FastCGI поддерживает постоянное соединение между веб-сервером и приложением, обеспечивая более быструю связь и снижая накладные расходы.
    Мультиплексирование : FastCGI позволяет обрабатывать несколько запросов по одному соединению, повышая производительность и сокращая количество требуемых соединений.
    Управление внешними процессами : FastCGI предоставляет механизм управления внешними процессами, позволяющий лучше контролировать использование ресурсов и улучшать масштабируемость.
    Улучшенная безопасность : FastCGI обеспечивает улучшенные функции безопасности, такие как контроль доступа и аутентификация, по сравнению с традиционным CGI.
    Преимущества перед CGI:

    Улучшенная производительность : постоянные соединения FastCGI и возможности мультиплексирования обеспечивают более быстрое время отклика и повышение общей производительности.
    Масштабируемость : способность FastCGI управлять внешними процессами и обрабатывать несколько запросов по одному соединению делает его более масштабируемым, чем традиционный CGI.
    Повышенная безопасность : улучшенные функции безопасности FastCGI обеспечивают лучшую защиту от распространенных веб-атак и уязвимостей.
    Снижение накладных расходов : снижение накладных расходов FastCGI по сравнению с CGI приводит к снижению потребления ресурсов и повышению эффективности системы.
    Недостатки по сравнению с CGI:

    Повышенная сложность : FastCGI требует более сложной конфигурации и настройки по сравнению с традиционным CGI.
    Проблемы совместимости : FastCGI может быть несовместим со всеми веб-серверами или приложениями, требуя дополнительной настройки или изменений.
    Более крутая кривая обучения : более сложная архитектура и функции FastCGI требуют более глубокого понимания веб-разработки и
    Сравнение FastCGI и CGI:

    Особенность	            CGI	                                                            FastCGI
    Тип соединения	        Без сохранения состояния, новое соединение для каждого запроса	Постоянные мультиплексные соединения
    Производительность	    Медленно, высокие накладные расходы	                            Быстро, с низкими накладными расходами
    Масштабируемость	    Ограниченный, новый процесс для каждого запроса	                Улучшенное внешнее управление процессами
    Безопасность	        Ограниченный, уязвимый для атак	                                Улучшенный контроль доступа и аутентификация

    В целом FastCGI предлагает значительные преимущества по сравнению с традиционным CGI с точки зрения производительности, масштабируемости и безопасности. Однако его повышенная сложность и проблемы совместимости могут сделать его менее подходящим для определенных приложений или сред.


-FastCGI сервер на языке Java.

    FastCGI-сервер на Java: реализация и соображения

    Хотя FastCGI обычно ассоциируется с такими языками, как C, Perl или Python, возможно реализовать сервер FastCGI на Java. Однако это требует некоторых дополнительных соображений и обходных путей из-за архитектуры Java и протокола FastCGI.

    Выполнение:

    Для реализации сервера FastCGI на Java можно использовать следующие подходы:

    Собственный интерфейс : используйте собственный интерфейс Java (JNI) для создания собственной библиотеки, которая взаимодействует с протоколом FastCGI. Этот подход требует написания собственного кода на C или C++ и использования JNI для взаимодействия с Java.
    Реализация на основе сокетов : реализация сервера FastCGI в Java с использованием программирования сокетов. Этот подход включает создание сервера сокетов Java, который прослушивает запросы FastCGI, обрабатывает их и возвращает ответы.
    Сторонние библиотеки : используйте сторонние библиотеки, такие как fcgi4j или javafcgi , которые предоставляют реализацию протокола FastCGI на Java. Эти библиотеки упрощают процесс создания сервера FastCGI на Java.
    Соображения:

    При реализации сервера FastCGI на Java следует учитывать следующее:

    Производительность : Виртуальная машина Java (JVM) вносит дополнительные накладные расходы по сравнению с собственными реализациями. Это может повлиять на производительность, особенно для приложений с высоким трафиком или ресурсоемких приложений.
    Управление памятью : механизм сборки мусора Java может приводить к паузам в работе приложения, что может повлиять на скорость отклика сервера FastCGI.
    Управление потоками : модель потоков Java может быть сложной, а неправильное управление потоками может привести к проблемам с производительностью или даже к сбоям.


